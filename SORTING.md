Основывался на  [Wiki](https://en.wikipedia.org/wiki/External_sorting)
## Алгоритм сортировки
Дан набор данных размером 900 Мб, объем оперативной памяти 100 МБ

1. Прочитать первые 100 МБ из первоначального набора и отсортировать любым алгоритмом сортировки, который не требует дополнительного расхода памяти, например quicksort 
2. Записать на диск отсортированные данные в отдельный файл, получим первый чанк 
3. Повторить шаги 1 и 2 до того момента пока не получится на выходе 9 файлов с отсортированными данными
4. Прочитать из каждого чанка по 10 МБ, 9*10МБ=90МБ, и остается 10МБ для выходного буфера
5. Теперь необходимо соединить отсоритированные части, для этого используем K-way merging: 
..* собрать головы всех 9 список 
..* записать в выходной буфер наименьший элемент 
..* удалить найденный элемент из списка 
..* повторять алгоритм пока не опустеет хотябы один список 
..* если хоть один список опустел продолжать слияние нельзя, так как участвует не все претенденты на звание текущего наименьшего элемента, такие элементы могут быть записаны в файл список которого опустел
..* повторять алгоритм сначала пока все файлы не опустеют

Конкретные размеры использования памяти могут быть оптимизированы для улучшения производительности, например считывание объема данных из одного чанка можно сократить, увеличив размер выходного буфера
Поднять скорость исполнения и более оптимально использовть память можно, если реализовать алгоритм читателя и писателя при считывании данных из чанков.
Альтернативный алгоритм с использованием многопоточности

1. Главный поток: Прочитать первые 100 МБ из первоначального набора и отсортировать любым алгоритмом сортировки, который не требует дополнительного расхода памяти, например quicksort 
2. Главный поток: Записать на диск отсортированные данные в отдельный файл, получим первый чанк 
3. Главный поток: Повторить шаги 1 и 2 до того момента пока не получится на выходе 9 файлов с отсортированными данными
4. Создаем 9 потоков читателей чанков
5. Каждый поток, должен использовать только 10 МБ оперативной памяти
6. Каждый поток читает по 10 МБ данных из своего чанка, и сразу выставляет кандидата из своего списка
7. Главный поток выступает читателем кандидатов, выбирает из них наименьший и записывает в выходной файл
8. Важный момент что теперь каждый из 9 потоков сам следит за доставлением кандидатов главному потоку, тем самым главный поток не тратит время на ожидание считывания от файловой системы, а только сортирует кандидатов
